<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Animated 3D Quote â€” Success</title>
  <style>
    /* Page reset */
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial}

    /* full-screen background gradient */
    body{
      background: radial-gradient(1200px 600px at 10% 10%, #0f172a 0%, #081021 20%, #0b1024 40%),
                  linear-gradient(135deg,#6a11cb 0%, #2575fc 55%, #00d2ff 100%);
      background-blend-mode: screen, normal;
      color:#fff;
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      perspective:1200px; /* give CSS 3D perspective */
    }

    /* glass panel for the quote */
    .card{
      width:min(900px,92vw);
      max-width:1100px;
      height:min(420px,60vh);
      border-radius:20px;
      backdrop-filter: blur(8px) saturate(140%);
      background:linear-gradient(135deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      box-shadow: 0 20px 60px rgba(10,10,25,0.6), inset 0 1px 0 rgba(255,255,255,0.03);
      padding:36px;
      display:grid;
      grid-template-columns: 1fr 420px;
      gap:24px;
      align-items:center;
      transform-style:preserve-3d;
      transform: translateZ(40px) rotateX(6deg);
    }

    h1{
      font-size:clamp(28px,5vw,44px);
      line-height:1.05;
      letter-spacing:0.2px;
      margin-bottom:14px;
      filter:drop-shadow(0 6px 18px rgba(0,0,0,0.5));
      transform: translateZ(40px) rotateX(0.5deg);
    }

    p.lead{
      opacity:0.9;font-size:clamp(14px,1.6vw,18px);
    }

    /* right side holds the canvas */
    .canvas-wrap{
      width:100%;height:100%;min-height:260px;position:relative;border-radius:14px;overflow:hidden;
      border:1px solid rgba(255,255,255,0.03);
    }

    /* floating small caption */
    .meta{position:absolute;left:18px;bottom:12px;font-size:12px;opacity:0.8}

    /* subtle animated underline on the heading */
    .underline{display:inline-block;position:relative}
    .underline:after{content:'';position:absolute;left:0;right:0;bottom:-8px;height:6px;border-radius:6px; background:linear-gradient(90deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02)); transform-origin:left; animation:underline 3.6s infinite}
    @keyframes underline{0%{transform:scaleX(0)}50%{transform:scaleX(1)}100%{transform:scaleX(0)}}

    /* responsive */
    @media (max-width:880px){.card{grid-template-columns:1fr;max-height:none;height:auto;padding:20px} .canvas-wrap{height:300px}}

    /* small helper for pointer cursor */
    .hint{font-size:12px;color:rgba(255,255,255,0.75)}
  </style>
</head>
<body>
  <div class="card" role="main">
    <div>
      <h1 class="underline">Success comes to those who work for it, not to those who wish for it.</h1>
      
      
    </div>

    <div class="canvas-wrap" id="canvas-wrap">
      <canvas id="three-canvas"></canvas>
      
    </div>
  </div>

  <!-- Three.js as an ES module (requires modern browser) -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.158.0/examples/jsm/controls/OrbitControls.js';

    const canvasWrap = document.getElementById('canvas-wrap');
    const canvas = document.getElementById('three-canvas');

    const renderer = new THREE.WebGLRenderer({canvas, antialias: true, alpha:true});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(canvasWrap.clientWidth, canvasWrap.clientHeight, false);

    const scene = new THREE.Scene();

    // subtle fog to blend with background
    scene.fog = new THREE.FogExp2(0x07101a, 0.03);

    // Camera
    const camera = new THREE.PerspectiveCamera(45, canvasWrap.clientWidth / canvasWrap.clientHeight, 0.1, 2000);
    camera.position.set(0, 0, 55);

    // Lights
    const amb = new THREE.AmbientLight(0xffffff, 0.25);
    scene.add(amb);
    const pointA = new THREE.PointLight(0xff77aa, 1.0, 400);
    pointA.position.set(40, 20, 40);
    scene.add(pointA);
    const pointB = new THREE.PointLight(0x33ccff, 0.9, 400);
    pointB.position.set(-40, -30, 60);
    scene.add(pointB);

    // Materials
    const shinyMat = new THREE.MeshStandardMaterial({metalness:0.6, roughness:0.15, emissiveIntensity:0.2});
    const glassish = new THREE.MeshPhysicalMaterial({metalness:0.05, roughness:0.12, transmission:0.75, transparent:true, ior:1.4});

    // Torus knot (main) - energetic and dynamic
    const knotGeo = new THREE.TorusKnotGeometry(8, 2.2, 220, 32);
    const knot = new THREE.Mesh(knotGeo, shinyMat);
    knot.position.set(-6, 0, 0);
    scene.add(knot);

    // floating sphere
    const sphereGeom = new THREE.SphereGeometry(6, 64, 64);
    const sphere = new THREE.Mesh(sphereGeom, glassish);
    sphere.position.set(14, 2, -6);
    scene.add(sphere);

    // particle field
    const particles = new THREE.BufferGeometry();
    const count = 1200;
    const positions = new Float32Array(count * 3);
    for(let i=0;i<count;i++){
      const r = 30 + Math.random()*120;
      const theta = Math.random()*Math.PI*2;
      const phi = (Math.random()-0.5)*Math.PI;
      positions[i*3+0] = Math.cos(theta)*r*Math.cos(phi);
      positions[i*3+1] = Math.sin(phi)*r*0.4;
      positions[i*3+2] = Math.sin(theta)*r*Math.cos(phi);
    }
    particles.setAttribute('position', new THREE.BufferAttribute(positions,3));
    const pointMat = new THREE.PointsMaterial({size:0.9, transparent:true, opacity:0.85});
    const points = new THREE.Points(particles, pointMat);
    scene.add(points);

    // subtle gentle rotation linked to mouse
    const pointer = {x:0,y:0};
    window.addEventListener('mousemove', (e)=>{
      const rect = canvasWrap.getBoundingClientRect();
      pointer.x = ((e.clientX - rect.left) / rect.width - 0.5) * 2;
      pointer.y = ((e.clientY - rect.top) / rect.height - 0.5) * 2;
    });
    window.addEventListener('touchmove',(e)=>{
      if(!e.touches) return;
      const t = e.touches[0];
      const rect = canvasWrap.getBoundingClientRect();
      pointer.x = ((t.clientX - rect.left) / rect.width - 0.5) * 2;
      pointer.y = ((t.clientY - rect.top) / rect.height - 0.5) * 2;
    },{passive:true});

    // Animate
    const clock = new THREE.Clock();
    function animate(){
      const t = clock.getElapsedTime();

      // rotate main objects
      knot.rotation.x = 0.2*t + pointer.y*0.3;
      knot.rotation.y = 0.6*t + pointer.x*0.6;
      knot.rotation.z = 0.12*t;

      sphere.rotation.y = -0.2*t + pointer.x*0.15;
      sphere.position.x = 14 + Math.sin(t*0.8)*1.8;
      sphere.position.y = 2 + Math.cos(t*0.7)*1.2;

      // particle slow swirl
      points.rotation.y = 0.02*t + pointer.x*0.1;
      points.rotation.x = 0.01*t + pointer.y*0.04;

      // subtle color cycling for lights and points
      const cA = new THREE.Color().setHSL((Math.sin(t*0.3)+1)/2*0.08 + 0.9, 0.7, 0.6);
      pointA.color.copy(cA);
      const cB = new THREE.Color().setHSL((Math.cos(t*0.18)+1)/2*0.2 + 0.5, 0.8, 0.5);
      pointB.color.copy(cB);

      // make points shimmer by adjusting material size via sine
      pointMat.size = 0.7 + (Math.sin(t*2.0)+1.0)*0.4;

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    // handle resizing
    function resize(){
      const w = canvasWrap.clientWidth;
      const h = canvasWrap.clientHeight;
      renderer.setSize(w,h,false);
      camera.aspect = w/h;
      camera.updateProjectionMatrix();
    }
    new ResizeObserver(resize).observe(canvasWrap);

    // subtle parallax effect on the card itself for extra 3D depth
    const card = document.querySelector('.card');
    document.addEventListener('mousemove', (e)=>{
      const rect = card.getBoundingClientRect();
      const cx = rect.left + rect.width/2;
      const cy = rect.top + rect.height/2;
      const dx = (e.clientX - cx)/rect.width;
      const dy = (e.clientY - cy)/rect.height;
      card.style.transform = `translateZ(40px) rotateX(${dy*6}deg) rotateY(${dx*10}deg)`;
    });

  </script>
</body>
</html>
